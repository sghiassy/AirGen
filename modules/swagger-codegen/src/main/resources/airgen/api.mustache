{{#operations}}
//
// {{classname}}Requests.swift
//
// Generated by AirGen
// Mustache template author: Shaheen Ghiassy (shaheen@groupon.com)
//

//
//       ____  ____     _   ______  ______   __________  __________
//      / __ \/ __ \   / | / / __ \/_  __/  / ____/ __ \/  _/_  __/
//     / / / / / / /  /  |/ / / / / / /    / __/ / / / // /  / /
//    / /_/ / /_/ /  / /|  / /_/ / / /    / /___/ /_/ // /  / /
//   /_____/\____/  /_/ |_/\____/ /_/    /_____/_____/___/ /_/
//
//   THIS FILE WAS AUTO-GENERATED

import AirGap

{{> RequestsBaseObjects}}

{{#operation}}
public class {{operationIdCamelCase}}Request: AirGenRequest {

    public static let verb: RequestType = .{{httpMethod}}
    public static let urlDefinition: String = "{{basePath}}{{{path}}}"
    public var absoluteStringURL: String { return AbsoluteStringURL(urlDefinition: self.urlDefinition, params: self.path.serialize()) }
    public var absoluteURL: URL { return URL(string: self.absoluteStringURL)! } // Note: The URL explicit unwrap is safe here, since all objects are immutable and can't be allocated until the compiler ensures they meet the Swagger Spec

{{> RequestParamsPath}}
{{> RequestParamsHeader}}
{{> RequestParamsQuery}}

{{#hasPathParams}}
    public let path: {{operationIdCamelCase}}Request.Path
{{/hasPathParams}}
{{^hasPathParams}}
    public let path = AirGenPath()
{{/hasPathParams}}
{{#hasQueryParams}}
    public let query: {{operationIdCamelCase}}Request.Query
{{/hasQueryParams}}
{{^hasQueryParams}}
    public let query = AirGenQuery()
{{/hasQueryParams}}
{{#hasHeaderParams}}
    public let headers: {{operationIdCamelCase}}Request.Headers
{{/hasHeaderParams}}
{{#hasBodyParam}}
    public let body: {{#bodyParam}}{{dataType}}{{/bodyParam}}
{{/hasBodyParam}}

    {{#hasParams}}
    public init(
        {{#hasPathParams}}path: {{operationIdCamelCase}}Request.Path{{/hasPathParams}}
        {{#hasHeaderParams}}{{#hasPathParams}}, {{/hasPathParams}}headers: {{operationIdCamelCase}}Request.Headers{{/hasHeaderParams}}
        {{#hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}query: {{operationIdCamelCase}}Request.Query{{#hasBodyParam}},{{/hasBodyParam}}{{/hasQueryParams}}
        {{#hasBodyParam}}body: {{#bodyParam}}{{dataType}}{{/bodyParam}}{{/hasBodyParam}}) {
        {{#hasBodyParam}}
            self.body = body
        {{/hasBodyParam}}
        {{#hasPathParams}}
            self.path = path
        {{/hasPathParams}}
        {{#hasHeaderParams}}
            self.headers = headers
        {{/hasHeaderParams}}
        {{#hasParams}}
            self.query = query
        {{/hasParams}}
        super.init(verb: {{operationIdCamelCase}}Request.verb, urlDefinition: {{operationIdCamelCase}}Request.urlDefinition)
    }
    {{/hasParams}}

    {{#hasParams}}
    convenience init?(source: Any) {
        guard
            let source = source as? SourceType{{#hasParams}},{{/hasParams}}
            {{#hasBodyParam}}
            let body = {{#bodyParam}}{{dataType}}{{/bodyParam}}(source: source["body"]),
            {{/hasBodyParam}}
            {{#hasPathParams}}
            let path = {{operationIdCamelCase}}Request.Path(source: source["path"]),
            {{/hasPathParams}}
            {{#hasHeaderParams}}
            let headers = {{operationIdCamelCase}}Request.Headers(source: source["headers"]),
            {{/hasHeaderParams}}
            {{#hasQueryParams}}
            let query = {{operationIdCamelCase}}Request.Query(source: source["query"])
            {{/hasQueryParams}}
        else {
            return nil
        }

        self.init(
            {{#hasPathParams}}
                path: path
            {{/hasPathParams}}
            {{#hasHeaderParams}}
                {{#hasPathParams}}, {{/hasPathParams}}
                headers: headers
            {{/hasHeaderParams}}
            {{#hasQueryParams}}
                {{#hasPathParams}}, {{/hasPathParams}}
                query: query{{#hasBodyParam}},{{/hasBodyParam}}
            {{/hasQueryParams}}
            {{#hasBodyParam}}
                body: body
            {{/hasBodyParam}})
    }
    {{/hasParams}}

    override public var description: String {
        return """
        URL: \(self.verb): \(self.urlDefinition)
        {{#hasHeaderParams}}
        HEADERS: \(self.headers)
        {{/hasHeaderParams}}
        {{#hasParams}}
        PARAMS: \(self.query)
        {{/hasParams}}
        {{#hasBodyParam}}
        BODY: \(self.body)
        {{/hasBodyParam}}
        """
    }

}

{{/operation}}

fileprivate func AbsoluteStringURL(urlDefinition: String, params: [String:String]) -> String {
    var split: [String] = urlDefinition.split(separator: "/").map({ String($0) })
    split = split.map({ el in
        if el.first == ":" {
            return params[String(el.dropFirst())]!
        } else {
            return el
        }
    })
    split[0] = split[0] + "/"
    return split.joined(separator: "/")
}

fileprivate func AbsoluteURL(urlDefinition: String, params: [String:String]) -> URL {
    return URL(string: AbsoluteStringURL(urlDefinition:urlDefinition, params:params))!
}

{{/operations}}

