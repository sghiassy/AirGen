



internal func queryString(from queryParams:[String:String]?) -> String {
    guard let queryParams = queryParams else { return "" }

    // Wrap the whole thing in a string to avoid return SubStringSequenceType (i.e: because of the dropLast function)
    return String(
        // Reduce down the String Dictionary into a single string
        queryParams.reduce("?") { ( sum: String, keyValue: (String, String)) -> String in
            return sum + "\(keyValue.0)=\(keyValue.1)&"
            }
            .dropLast() // Remove the remaining "&" ampersand from the string
    )
}

internal func urlString(from urlDefinition: String, pathParams: [String:String]?) -> String {
    guard let pathParams = pathParams else { return urlDefinition }

    var urlPathKeys: [String] = urlDefinition.split(separator: "/") // Split the URL by '/' slash token
                                             .map({ String($0) }) // Manually convert the StringSequence type returned by the split function to a regular String type
    urlPathKeys = urlPathKeys.map({ el in
        if el.first == ":" {
            return pathParams[String(el.dropFirst())]!
        } else {
            return el
        }
    })
    urlPathKeys[0] = urlPathKeys[0] + "/"
    return urlPathKeys.joined(separator: "/")
}


internal func AbsoluteStringURL(urlDefinition: String, pathParams: [String:String]?, queryParams:[String:String]?) -> String {
    return urlString(from: urlDefinition, pathParams: pathParams) + queryString(from: queryParams)
}

internal func AbsoluteURL(urlDefinition: String, pathParams: [String:String]?, queryParams:[String:String]?) -> URL {
    return URL(string: AbsoluteStringURL(urlDefinition: urlDefinition, pathParams: pathParams, queryParams: queryParams))!
}

public extension Encodable {
    var asDictionary: [String: Any]? {
        guard let data = try? JSONEncoder().encode(self) else { return nil }
        return (try? JSONSerialization.jsonObject(with: data, options: .allowFragments)).flatMap { $0 as? [String: Any] }
    }
    var asStringDictionary: [String:String]? {
        return self.asDictionary?.mapValues({ (val) -> String in
            return "\(val)"
        })
    }
}